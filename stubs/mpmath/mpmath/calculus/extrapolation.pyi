from _typeshed import Incomplete
from collections.abc import Generator

izip = zip
next = next

def richardson(ctx, seq): ...
def shanks(ctx, seq, table: Incomplete | None = None, randomized: bool = False): ...

class levin_class:
    variant: Incomplete
    n: int
    a0: int
    theta: int
    A: Incomplete
    B: Incomplete
    last: int
    last_s: bool
    factor: Incomplete
    def __init__(self, method: str = "levin", variant: str = "u") -> None: ...
    def factor_levin(self, i): ...
    def factor_sidi(self, i): ...
    def run(self, s, a0, a1: int = 0) -> None: ...
    a1: Incomplete
    def update_psum(self, S): ...
    s: Incomplete
    def update(self, X): ...
    last_w: Incomplete
    def step_psum(self, s): ...
    def step(self, x): ...

def levin(ctx, method: str = "levin", variant: str = "u"): ...

class cohen_alt_class:
    last: int
    def __init__(self) -> None: ...
    def update(self, A): ...
    def update_psum(self, S): ...

def cohen_alt(ctx): ...
def sumap(ctx, f, interval, integral: Incomplete | None = None, error: bool = False): ...
def sumem(
    ctx,
    f,
    interval,
    tol: Incomplete | None = None,
    reject: int = 10,
    integral: Incomplete | None = None,
    adiffs: Incomplete | None = None,
    bdiffs: Incomplete | None = None,
    verbose: bool = False,
    error: bool = False,
    _fast_abort: bool = False,
): ...
def adaptive_extrapolation(ctx, update, emfun, kwargs): ...
def nsum(ctx, f, *intervals, **options): ...
def wrapsafe(f): ...
def standardize(ctx, f, intervals, options): ...
def cartesian_product(args) -> Generator[Incomplete, None, None]: ...
def fold_finite(ctx, f, intervals): ...
def standardize_infinite(ctx, f, intervals): ...
def fold_infinite(ctx, f, intervals): ...
def nprod(ctx, f, interval, nsum: bool = False, **kwargs): ...
def limit(ctx, f, x, direction: int = 1, exp: bool = False, **kwargs): ...
