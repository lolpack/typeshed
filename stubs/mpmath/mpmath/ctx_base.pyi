from _typeshed import Incomplete

from . import libmp
from .calculus.calculus import CalculusMethods
from .calculus.inverselaplace import LaplaceTransformInversionMethods
from .calculus.odes import ODEMethods
from .calculus.optimization import OptimizationMethods
from .calculus.quadrature import QuadratureMethods
from .functions.functions import SpecialFunctions
from .functions.rszeta import RSCache
from .identification import IdentificationMethods
from .matrices.calculus import MatrixCalculusMethods
from .matrices.eigen import Eigen
from .matrices.linalg import LinearAlgebraMethods
from .matrices.matrices import MatrixMethods
from .visualization import VisualizationMethods

class Context: ...

class StandardBaseContext(
    Context,
    SpecialFunctions,
    RSCache,
    QuadratureMethods,
    LaplaceTransformInversionMethods,
    CalculusMethods,
    MatrixMethods,
    MatrixCalculusMethods,
    LinearAlgebraMethods,
    Eigen,
    IdentificationMethods,
    OptimizationMethods,
    ODEMethods,
    VisualizationMethods,
):
    NoConvergence = libmp.NoConvergence
    ComplexResult = libmp.ComplexResult
    def __init__(ctx) -> None: ...
    verbose: bool
    def warn(ctx, msg) -> None: ...
    def bad_domain(ctx, msg) -> None: ...
    def fneg(ctx, x, **kwargs): ...
    def fadd(ctx, x, y, **kwargs): ...
    def fsub(ctx, x, y, **kwargs): ...
    def fmul(ctx, x, y, **kwargs): ...
    def fdiv(ctx, x, y, **kwargs): ...
    def fsum(ctx, args, absolute: bool = False, squared: bool = False): ...
    def fdot(ctx, xs, ys: Incomplete | None = None, conjugate: bool = False): ...
    def fprod(ctx, args): ...
    def nprint(ctx, x, n: int = 6, **kwargs) -> None: ...
    def chop(ctx, x, tol: Incomplete | None = None): ...
    def almosteq(ctx, s, t, rel_eps: Incomplete | None = None, abs_eps: Incomplete | None = None): ...
    def arange(ctx, *args): ...
    def linspace(ctx, *args, **kwargs): ...
    def cos_sin(ctx, z, **kwargs): ...
    def cospi_sinpi(ctx, z, **kwargs): ...
    list_primes: Incomplete
    isprime: Incomplete
    bernfrac: Incomplete
    moebius: Incomplete
    def sum_accurately(ctx, terms, check_step: int = 1): ...
    def mul_accurately(ctx, factors, check_step: int = 1): ...
    def power(ctx, x, y): ...
    def maxcalls(ctx, f, N): ...
    def memoize(ctx, f): ...
