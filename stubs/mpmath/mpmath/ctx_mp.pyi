from _typeshed import Incomplete

from .ctx_base import StandardBaseContext
from .ctx_mp_python import PythonMPContext as BaseMPContext, mpnumeric as mpnumeric
from .libmp import (
    MPZ as MPZ,
    MPZ_ZERO as MPZ_ZERO,
    from_float as from_float,
    from_int as from_int,
    from_man_exp as from_man_exp,
    from_pickable as from_pickable,
    from_str as from_str,
    mpc_abs as mpc_abs,
    mpc_conjugate as mpc_conjugate,
    mpc_hash as mpc_hash,
    mpc_is_nonzero as mpc_is_nonzero,
    mpc_mpf_div as mpc_mpf_div,
    mpc_mul_int as mpc_mul_int,
    mpc_pos as mpc_pos,
    mpc_pow as mpc_pow,
    mpc_pow_int as mpc_pow_int,
    mpc_pow_mpf as mpc_pow_mpf,
    mpc_to_complex as mpc_to_complex,
    mpf_abs as mpf_abs,
    mpf_cmp as mpf_cmp,
    mpf_eq as mpf_eq,
    mpf_ge as mpf_ge,
    mpf_gt as mpf_gt,
    mpf_hash as mpf_hash,
    mpf_le as mpf_le,
    mpf_lt as mpf_lt,
    mpf_mod as mpf_mod,
    mpf_mul_int as mpf_mul_int,
    mpf_pos as mpf_pos,
    mpf_pow as mpf_pow,
    mpf_pow_int as mpf_pow_int,
    mpf_rdiv_int as mpf_rdiv_int,
    mpf_sum as mpf_sum,
    normalize as normalize,
    prec_to_dps as prec_to_dps,
    round_ceiling as round_ceiling,
    round_floor as round_floor,
    round_nearest as round_nearest,
    to_fixed as to_fixed,
    to_float as to_float,
    to_int as to_int,
    to_pickable as to_pickable,
)

__docformat__: str
new: Incomplete
get_complex: Incomplete

class MPContext(BaseMPContext, StandardBaseContext):
    def __init__(ctx) -> None: ...
    def init_builtins(ctx): ...
    def to_fixed(ctx, x, prec): ...
    def hypot(ctx, x, y): ...
    def bernoulli(ctx, n): ...
    def atan2(ctx, y, x): ...
    def psi(ctx, m, z): ...
    def cos_sin(ctx, x, **kwargs): ...
    def cospi_sinpi(ctx, x, **kwargs): ...
    def clone(ctx): ...
    def isnan(ctx, x): ...
    def isfinite(ctx, x): ...
    def isnpint(ctx, x): ...
    def extraprec(ctx, n, normalize_output: bool = False): ...
    def extradps(ctx, n, normalize_output: bool = False): ...
    def workprec(ctx, n, normalize_output: bool = False): ...
    def workdps(ctx, n, normalize_output: bool = False): ...
    def autoprec(ctx, f, maxprec: Incomplete | None = None, catch=(), verbose: bool = False): ...
    def nstr(ctx, x, n: int = 6, **kwargs): ...
    def mpmathify(ctx, *args, **kwargs): ...
    def hypsum(ctx, p, q, flags, coeffs, z, accurate_small: bool = True, **kwargs): ...
    def ldexp(ctx, x, n): ...
    def frexp(ctx, x): ...
    def fneg(ctx, x, **kwargs): ...
    def fadd(ctx, x, y, **kwargs): ...
    def fsub(ctx, x, y, **kwargs): ...
    def fmul(ctx, x, y, **kwargs): ...
    def fdiv(ctx, x, y, **kwargs): ...
    def nint_distance(ctx, x): ...
    def fprod(ctx, factors): ...
    def rand(ctx): ...
    def fraction(ctx, p, q): ...
    def absmin(ctx, x): ...
    def absmax(ctx, x): ...

class PrecisionManager:
    ctx: Incomplete
    precfun: Incomplete
    dpsfun: Incomplete
    normalize_output: Incomplete
    def __init__(self, ctx, precfun, dpsfun, normalize_output: bool = False) -> None: ...
    def __call__(self, f): ...
    origp: Incomplete
    def __enter__(self) -> None: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None
    ): ...
