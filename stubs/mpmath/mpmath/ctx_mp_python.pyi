from _typeshed import Incomplete

from .libmp import (
    MPZ_ONE as MPZ_ONE,
    MPZ_ZERO as MPZ_ZERO,
    fone as fone,
    mpc_mpf_div as mpc_mpf_div,
    mpf_add as mpf_add,
    mpf_apery as mpf_apery,
    mpf_catalan as mpf_catalan,
    mpf_degree as mpf_degree,
    mpf_div as mpf_div,
    mpf_e as mpf_e,
    mpf_eq as mpf_eq,
    mpf_euler as mpf_euler,
    mpf_glaisher as mpf_glaisher,
    mpf_khinchin as mpf_khinchin,
    mpf_ln2 as mpf_ln2,
    mpf_ln10 as mpf_ln10,
    mpf_mertens as mpf_mertens,
    mpf_mod as mpf_mod,
    mpf_mul_int as mpf_mul_int,
    mpf_phi as mpf_phi,
    mpf_pi as mpf_pi,
    mpf_pow as mpf_pow,
    mpf_pow_int as mpf_pow_int,
    mpf_rand as mpf_rand,
    mpf_twinprime as mpf_twinprime,
    repr_dps as repr_dps,
    round_ceiling as round_ceiling,
    round_floor as round_floor,
)

new: Incomplete

class mpnumeric:
    def __new__(cls, val) -> None: ...

class _mpf(mpnumeric):
    def __new__(cls, val=(0, 0, 0, 0), **kwargs): ...
    @classmethod
    def mpf_convert_arg(cls, x, prec, rounding): ...
    @classmethod
    def mpf_convert_rhs(cls, x): ...
    @classmethod
    def mpf_convert_lhs(cls, x): ...
    man_exp: Incomplete
    man: Incomplete
    exp: Incomplete
    bc: Incomplete
    real: Incomplete
    imag: Incomplete
    conjugate: Incomplete
    def __hash__(s): ...
    def __int__(s) -> int: ...
    def __long__(s): ...
    def __float__(s) -> float: ...
    def __complex__(s) -> complex: ...
    def __nonzero__(s): ...
    __bool__ = __nonzero__
    def __abs__(s): ...
    def __pos__(s): ...
    def __neg__(s): ...
    def __cmp__(s, t): ...
    def __lt__(s, t): ...
    def __gt__(s, t): ...
    def __le__(s, t): ...
    def __ge__(s, t): ...
    def __ne__(s, t): ...
    def __rsub__(s, t): ...
    def __rdiv__(s, t): ...
    def __rpow__(s, t): ...
    def __rmod__(s, t): ...
    def sqrt(s): ...
    def ae(s, t, rel_eps: Incomplete | None = None, abs_eps: Incomplete | None = None): ...
    def to_fixed(self, prec): ...
    def __round__(self, *args): ...

mpf_binary_op: str
return_mpf: str
return_mpc: str
mpf_pow_same: Incomplete

def binary_op(name, with_mpf: str = "", with_int: str = "", with_mpc: str = ""): ...

class _constant(_mpf):
    def __new__(cls, func, name, docname: str = ""): ...
    def __call__(self, prec: Incomplete | None = None, dps: Incomplete | None = None, rounding: Incomplete | None = None): ...

class _mpc(mpnumeric):
    def __new__(cls, real: int = 0, imag: int = 0): ...
    real: Incomplete
    imag: Incomplete
    def __complex__(s) -> complex: ...
    def __pos__(s): ...
    def __abs__(s): ...
    def __neg__(s): ...
    def conjugate(s): ...
    def __nonzero__(s): ...
    __bool__ = __nonzero__
    def __hash__(s): ...
    @classmethod
    def mpc_convert_lhs(cls, x): ...
    def __eq__(s, t): ...
    def __ne__(s, t): ...
    __gt__: Incomplete
    __le__: Incomplete
    __ge__: Incomplete
    def __add__(s, t): ...
    def __sub__(s, t): ...
    def __mul__(s, t): ...
    def __div__(s, t): ...
    def __pow__(s, t): ...
    __radd__ = __add__
    def __rsub__(s, t): ...
    def __rmul__(s, t): ...
    def __rdiv__(s, t): ...
    def __rpow__(s, t): ...
    __truediv__ = __div__
    __rtruediv__ = __rdiv__
    def ae(s, t, rel_eps: Incomplete | None = None, abs_eps: Incomplete | None = None): ...

complex_types: Incomplete

class PythonMPContext:
    def __init__(ctx) -> None: ...
    def make_mpf(ctx, v): ...
    def make_mpc(ctx, v): ...
    def default(ctx) -> None: ...
    prec: Incomplete
    dps: Incomplete
    def convert(ctx, x, strings: bool = True): ...
    def npconvert(ctx, x): ...
    def isnan(ctx, x): ...
    def isinf(ctx, x): ...
    def isnormal(ctx, x): ...
    def isint(ctx, x, gaussian: bool = False): ...
    def fsum(ctx, terms, absolute: bool = False, squared: bool = False): ...
    def fdot(ctx, A, B: Incomplete | None = None, conjugate: bool = False): ...
    def mag(ctx, x): ...
