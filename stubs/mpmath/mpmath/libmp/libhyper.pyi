from .backend import xrange as xrange
from .libelefun import mpf_cos as mpf_cos
from .libintmath import gcd as gcd
from .libmpc import mpc_mul_mpf as mpc_mul_mpf, mpc_square as mpc_square, mpc_sub_mpf as mpc_sub_mpf
from .libmpf import (
    mpf_cmp as mpf_cmp,
    mpf_gt as mpf_gt,
    mpf_rdiv_int as mpf_rdiv_int,
    round_nearest as round_nearest,
    to_rational as to_rational,
)

class NoConvergence(Exception): ...

def make_hyp_summator(key): ...
def mpf_erf(x, prec, rnd="d"): ...
def erfc_check_series(x, prec): ...
def mpf_erfc(x, prec, rnd="d"): ...
def ei_taylor(x, prec): ...
def complex_ei_taylor(zre, zim, prec): ...
def ei_asymptotic(x, prec): ...
def complex_ei_asymptotic(zre, zim, prec): ...
def mpf_ei(x, prec, rnd="d", e1: bool = False): ...
def mpc_ei(z, prec, rnd="d", e1: bool = False): ...
def mpf_e1(x, prec, rnd="d"): ...
def mpc_e1(x, prec, rnd="d"): ...
def mpf_expint(n, x, prec, rnd="d", gamma: bool = False): ...
def mpf_ci_si_taylor(x, wp, which: int = 0): ...
def mpc_ci_si_taylor(re, im, wp, which: int = 0): ...
def mpf_ci_si(x, prec, rnd="d", which: int = 2): ...
def mpf_ci(x, prec, rnd="d"): ...
def mpf_si(x, prec, rnd="d"): ...
def mpc_ci(z, prec, rnd="d"): ...
def mpc_si(z, prec, rnd="d"): ...
def mpf_besseljn(n, x, prec, rounding="d"): ...
def mpc_besseljn(n, z, prec, rounding="d"): ...
def mpf_agm(a, b, prec, rnd="d"): ...
def mpf_agm1(a, prec, rnd="d"): ...
def mpc_agm(a, b, prec, rnd="d"): ...
def mpc_agm1(a, prec, rnd="d"): ...
def mpf_ellipk(x, prec, rnd="d"): ...
def mpc_ellipk(z, prec, rnd="d"): ...
def mpf_ellipe(x, prec, rnd="d"): ...
def mpc_ellipe(z, prec, rnd="d"): ...
