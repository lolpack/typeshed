"""
This type stub file was generated by pyright.
"""

from .ctx_base import StandardBaseContext
from . import libmp

class FPContext(StandardBaseContext):
    """
    Context for fast low-precision arithmetic (53-bit precision, giving at most
    about 15-digit accuracy), using Python's builtin float and complex.
    """
    def __init__(ctx) -> None:
        ...
    
    _mpq = ...
    NoConvergence = libmp.NoConvergence
    _fixed_precision = ...
    prec = ...
    dps = ...
    zero = ...
    one = ...
    eps = ...
    inf = ...
    ninf = ...
    nan = ...
    j = ...
    def bernoulli(ctx, n):
        ...
    
    pi = ...
    e = ...
    euler = ...
    sqrt2 = ...
    sqrt5 = ...
    phi = ...
    ln2 = ...
    ln10 = ...
    euler = ...
    catalan = ...
    khinchin = ...
    apery = ...
    glaisher = ...
    absmax = ...
    def is_special(ctx, x):
        ...
    
    def isnan(ctx, x):
        ...
    
    def isinf(ctx, x):
        ...
    
    def isnormal(ctx, x): # -> Literal[False]:
        ...
    
    def isnpint(ctx, x): # -> bool:
        ...
    
    mpf = float
    mpc = complex
    def convert(ctx, x): # -> float | complex:
        ...
    
    power = ...
    sqrt = ...
    exp = ...
    log = ...
    cos = ...
    sin = ...
    tan = ...
    cos_sin = ...
    acos = ...
    asin = ...
    atan = ...
    cosh = ...
    sinh = ...
    tanh = ...
    gamma = ...
    rgamma = ...
    factorial = ...
    floor = ...
    ceil = ...
    cospi = ...
    sinpi = ...
    cbrt = ...
    _nthroot = ...
    _ei = ...
    _e1 = ...
    _zeta_int = ...
    def arg(ctx, z): # -> float:
        ...
    
    def expj(ctx, x):
        ...
    
    def expjpi(ctx, x):
        ...
    
    ldexp = ...
    frexp = ...
    def mag(ctx, z): # -> float:
        ...
    
    def isint(ctx, z): # -> Literal[False]:
        ...
    
    def nint_distance(ctx, z): # -> tuple[Any, float] | tuple[Any, Any | float]:
        ...
    
    def hypsum(ctx, p, q, types, coeffs, z, maxterms=..., **kwargs): # -> None:
        ...
    
    def atan2(ctx, x, y): # -> float:
        ...
    
    def psi(ctx, m, z):
        ...
    
    digamma = ...
    def harmonic(ctx, x): # -> float | complex:
        ...
    
    nstr = str
    def to_fixed(ctx, x, prec): # -> int:
        ...
    
    def rand(ctx): # -> float:
        ...
    
    _erf = ...
    _erfc = ...
    def sum_accurately(ctx, terms, check_step=...): # -> float:
        ...
    


