"""
This type stub file was generated by pyright.
"""

from .ctx_base import StandardBaseContext

mpi_zero = ...
new = ...
def convert_mpf_(x, prec, rounding): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any]:
    ...

class ivmpf:
    """
    Interval arithmetic class. Precision is controlled by iv.prec.
    """
    def __new__(cls, x=...):
        ...
    
    def cast(self, cls, f_convert):
        ...
    
    def __int__(self) -> int:
        ...
    
    def __float__(self): # -> float:
        ...
    
    def __complex__(self): # -> complex:
        ...
    
    def __hash__(self) -> int:
        ...
    
    @property
    def real(self): # -> Self:
        ...
    
    @property
    def imag(self):
        ...
    
    def conjugate(self): # -> Self:
        ...
    
    @property
    def a(self):
        ...
    
    @property
    def b(self):
        ...
    
    @property
    def mid(self):
        ...
    
    @property
    def delta(self):
        ...
    
    __gt__ = ...
    __le__ = ...
    __gt__ = ...
    __ge__ = ...
    def __contains__(self, t):
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str | LiteralString:
        ...
    
    def __eq__(s, t) -> bool:
        ...
    
    def __ne__(s, t) -> bool:
        ...
    
    def __lt__(s, t) -> bool:
        ...
    
    def __le__(s, t) -> bool:
        ...
    
    def __gt__(s, t) -> bool:
        ...
    
    def __ge__(s, t) -> bool:
        ...
    
    def __abs__(self):
        ...
    
    def __pos__(self):
        ...
    
    def __neg__(self):
        ...
    
    def ae(s, t, rel_eps=..., abs_eps=...):
        ...
    


class ivmpc:
    def __new__(cls, re=..., im=...): # -> Self:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __repr__(s): # -> str:
        ...
    
    def __str__(s) -> str:
        ...
    
    @property
    def a(self):
        ...
    
    @property
    def b(self):
        ...
    
    @property
    def c(self):
        ...
    
    @property
    def d(self):
        ...
    
    @property
    def real(s):
        ...
    
    @property
    def imag(s):
        ...
    
    def conjugate(s):
        ...
    
    def overlap(s, t):
        ...
    
    def __contains__(s, t): # -> bool:
        ...
    
    def __eq__(s, t) -> bool:
        ...
    
    def __ne__(s, t) -> bool:
        ...
    
    def __lt__(s, t) -> bool:
        ...
    
    __ge__ = ...
    def __neg__(s):
        ...
    
    def __pos__(s):
        ...
    
    def __abs__(s):
        ...
    
    def ae(s, t, rel_eps=..., abs_eps=...):
        ...
    


class ivmpf_constant(ivmpf):
    def __new__(cls, f): # -> Self:
        ...
    
    _mpi_ = ...


class MPIntervalContext(StandardBaseContext):
    def __init__(ctx) -> None:
        ...
    
    prec = ...
    dps = ...
    def make_mpf(ctx, v): # -> ivmpf:
        ...
    
    def make_mpc(ctx, v): # -> ivmpc:
        ...
    
    def convert(ctx, x): # -> ivmpf | ivmpc:
        ...
    
    def nstr(ctx, x, n=..., **kwargs): # -> str | None:
        ...
    
    def mag(ctx, x): # -> int | ivmpf:
        ...
    
    def isnan(ctx, x): # -> Literal[False]:
        ...
    
    def isinf(ctx, x):
        ...
    
    def isint(ctx, x): # -> None:
        ...
    
    def ldexp(ctx, x, n): # -> ivmpf:
        ...
    
    def absmin(ctx, x):
        ...
    
    def absmax(ctx, x):
        ...
    
    def atan2(ctx, y, x): # -> ivmpf:
        ...
    
    def hypsum(ctx, p, q, types, coeffs, z, maxterms=..., **kwargs): # -> None:
        ...
    


