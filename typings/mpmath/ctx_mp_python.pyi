"""
This type stub file was generated by pyright.
"""

new = ...
class mpnumeric:
    """Base class for mpf and mpc."""
    __slots__ = ...
    def __new__(cls, val):
        ...
    


class _mpf(mpnumeric):
    """
    An mpf instance holds a real-valued floating-point number. mpf:s
    work analogously to Python floats, but support arbitrary-precision
    arithmetic.
    """
    __slots__ = ...
    def __new__(cls, val=..., **kwargs): # -> _mpf | Self:
        """A new mpf can be created from a Python float, an int, a
        or a decimal string representing a number in floating-point
        format."""
        ...
    
    @classmethod
    def mpf_convert_arg(cls, x, prec, rounding): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any]:
        ...
    
    @classmethod
    def mpf_convert_rhs(cls, x): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | _NotImplementedType:
        ...
    
    @classmethod
    def mpf_convert_lhs(cls, x): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | _NotImplementedType:
        ...
    
    man_exp = ...
    man = ...
    exp = ...
    bc = ...
    real = ...
    imag = ...
    conjugate = ...
    def __getstate__(self): # -> tuple[Any, str, Any, Any]:
        ...
    
    def __setstate__(self, val): # -> None:
        ...
    
    def __repr__(s): # -> str:
        ...
    
    def __str__(s) -> str:
        ...
    
    def __hash__(s) -> int:
        ...
    
    def __int__(s) -> int:
        ...
    
    def __long__(s):
        ...
    
    def __float__(s): # -> float:
        ...
    
    def __complex__(s): # -> complex:
        ...
    
    def __nonzero__(s): # -> bool:
        ...
    
    __bool__ = ...
    def __abs__(s):
        ...
    
    def __pos__(s):
        ...
    
    def __neg__(s):
        ...
    
    def __cmp__(s, t): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | _NotImplementedType:
        ...
    
    def __lt__(s, t) -> bool:
        ...
    
    def __gt__(s, t) -> bool:
        ...
    
    def __le__(s, t) -> bool:
        ...
    
    def __ge__(s, t) -> bool:
        ...
    
    def __ne__(s, t) -> bool:
        ...
    
    def __rsub__(s, t): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | _NotImplementedType:
        ...
    
    def __rdiv__(s, t): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | _NotImplementedType:
        ...
    
    def __rpow__(s, t): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | _NotImplementedType:
        ...
    
    def __rmod__(s, t): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | _NotImplementedType:
        ...
    
    def sqrt(s):
        ...
    
    def ae(s, t, rel_eps=..., abs_eps=...):
        ...
    
    def to_fixed(self, prec):
        ...
    
    def __round__(self, *args): # -> float:
        ...
    


mpf_binary_op = ...
return_mpf = ...
return_mpc = ...
mpf_pow_same = ...
def binary_op(name, with_mpf=..., with_int=..., with_mpc=...):
    ...

class _constant(_mpf):
    """Represents a mathematical constant with dynamic precision.
    When printed or used in an arithmetic operation, a constant
    is converted to a regular mpf at the working precision. A
    regular mpf can also be obtained using the operation +x."""
    def __new__(cls, func, name, docname=...): # -> Self:
        ...
    
    def __call__(self, prec=..., dps=..., rounding=...):
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    


class _mpc(mpnumeric):
    """
    An mpc represents a complex number using a pair of mpf:s (one
    for the real part and another for the imaginary part.) The mpc
    class behaves fairly similarly to Python's complex type.
    """
    __slots__ = ...
    def __new__(cls, real=..., imag=...): # -> Self:
        ...
    
    real = ...
    imag = ...
    def __getstate__(self): # -> tuple[tuple[Any, str, Any, Any], tuple[Any, str, Any, Any]]:
        ...
    
    def __setstate__(self, val): # -> None:
        ...
    
    def __repr__(s): # -> str:
        ...
    
    def __str__(s) -> str:
        ...
    
    def __complex__(s): # -> complex:
        ...
    
    def __pos__(s):
        ...
    
    def __abs__(s):
        ...
    
    def __neg__(s):
        ...
    
    def conjugate(s):
        ...
    
    def __nonzero__(s): # -> bool:
        ...
    
    __bool__ = ...
    def __hash__(s) -> int:
        ...
    
    @classmethod
    def mpc_convert_lhs(cls, x): # -> _NotImplementedType:
        ...
    
    def __eq__(s, t) -> bool:
        ...
    
    def __ne__(s, t) -> bool:
        ...
    
    __gt__ = ...
    __le__ = ...
    __gt__ = ...
    __ge__ = ...
    def __add__(s, t): # -> _NotImplementedType:
        ...
    
    def __sub__(s, t): # -> _NotImplementedType:
        ...
    
    def __mul__(s, t): # -> _NotImplementedType:
        ...
    
    def __div__(s, t): # -> _NotImplementedType:
        ...
    
    def __pow__(s, t): # -> _NotImplementedType:
        ...
    
    __radd__ = ...
    def __rsub__(s, t): # -> _NotImplementedType:
        ...
    
    def __rmul__(s, t): # -> _NotImplementedType:
        ...
    
    def __rdiv__(s, t): # -> _NotImplementedType:
        ...
    
    def __rpow__(s, t): # -> _NotImplementedType:
        ...
    
    __truediv__ = ...
    __rtruediv__ = ...
    def ae(s, t, rel_eps=..., abs_eps=...):
        ...
    


complex_types = ...
class PythonMPContext:
    def __init__(ctx) -> None:
        ...
    
    def make_mpf(ctx, v): # -> mpf:
        ...
    
    def make_mpc(ctx, v): # -> mpc:
        ...
    
    def default(ctx): # -> None:
        ...
    
    prec = ...
    dps = ...
    def convert(ctx, x, strings=...): # -> mpf | mpc:
        """
        Converts *x* to an ``mpf`` or ``mpc``. If *x* is of type ``mpf``,
        ``mpc``, ``int``, ``float``, ``complex``, the conversion
        will be performed losslessly.

        If *x* is a string, the result will be rounded to the present
        working precision. Strings representing fractions or complex
        numbers are permitted.

            >>> from mpmath import *
            >>> mp.dps = 15; mp.pretty = False
            >>> mpmathify(3.5)
            mpf('3.5')
            >>> mpmathify('2.1')
            mpf('2.1000000000000001')
            >>> mpmathify('3/4')
            mpf('0.75')
            >>> mpmathify('2+3j')
            mpc(real='2.0', imag='3.0')

        """
        ...
    
    def npconvert(ctx, x): # -> mpf | mpc:
        """
        Converts *x* to an ``mpf`` or ``mpc``. *x* should be a numpy
        scalar.
        """
        ...
    
    def isnan(ctx, x): # -> bool:
        """
        Return *True* if *x* is a NaN (not-a-number), or for a complex
        number, whether either the real or complex part is NaN;
        otherwise return *False*::

            >>> from mpmath import *
            >>> isnan(3.14)
            False
            >>> isnan(nan)
            True
            >>> isnan(mpc(3.14,2.72))
            False
            >>> isnan(mpc(3.14,nan))
            True

        """
        ...
    
    def isinf(ctx, x): # -> bool:
        """
        Return *True* if the absolute value of *x* is infinite;
        otherwise return *False*::

            >>> from mpmath import *
            >>> isinf(inf)
            True
            >>> isinf(-inf)
            True
            >>> isinf(3)
            False
            >>> isinf(3+4j)
            False
            >>> isinf(mpc(3,inf))
            True
            >>> isinf(mpc(inf,3))
            True

        """
        ...
    
    def isnormal(ctx, x): # -> bool:
        """
        Determine whether *x* is "normal" in the sense of floating-point
        representation; that is, return *False* if *x* is zero, an
        infinity or NaN; otherwise return *True*. By extension, a
        complex number *x* is considered "normal" if its magnitude is
        normal::

            >>> from mpmath import *
            >>> isnormal(3)
            True
            >>> isnormal(0)
            False
            >>> isnormal(inf); isnormal(-inf); isnormal(nan)
            False
            False
            False
            >>> isnormal(0+0j)
            False
            >>> isnormal(0+3j)
            True
            >>> isnormal(mpc(2,nan))
            False
        """
        ...
    
    def isint(ctx, x, gaussian=...): # -> bool:
        """
        Return *True* if *x* is integer-valued; otherwise return
        *False*::

            >>> from mpmath import *
            >>> isint(3)
            True
            >>> isint(mpf(3))
            True
            >>> isint(3.2)
            False
            >>> isint(inf)
            False

        Optionally, Gaussian integers can be checked for::

            >>> isint(3+0j)
            True
            >>> isint(3+2j)
            False
            >>> isint(3+2j, gaussian=True)
            True

        """
        ...
    
    def fsum(ctx, terms, absolute=..., squared=...): # -> mpc | mpf:
        """
        Calculates a sum containing a finite number of terms (for infinite
        series, see :func:`~mpmath.nsum`). The terms will be converted to
        mpmath numbers. For len(terms) > 2, this function is generally
        faster and produces more accurate results than the builtin
        Python function :func:`sum`.

            >>> from mpmath import *
            >>> mp.dps = 15; mp.pretty = False
            >>> fsum([1, 2, 0.5, 7])
            mpf('10.5')

        With squared=True each term is squared, and with absolute=True
        the absolute value of each term is used.
        """
        ...
    
    def fdot(ctx, A, B=..., conjugate=...): # -> mpc | mpf:
        r"""
        Computes the dot product of the iterables `A` and `B`,

        .. math ::

            \sum_{k=0} A_k B_k.

        Alternatively, :func:`~mpmath.fdot` accepts a single iterable of pairs.
        In other words, ``fdot(A,B)`` and ``fdot(zip(A,B))`` are equivalent.
        The elements are automatically converted to mpmath numbers.

        With ``conjugate=True``, the elements in the second vector
        will be conjugated:

        .. math ::

            \sum_{k=0} A_k \overline{B_k}

        **Examples**

            >>> from mpmath import *
            >>> mp.dps = 15; mp.pretty = False
            >>> A = [2, 1.5, 3]
            >>> B = [1, -1, 2]
            >>> fdot(A, B)
            mpf('6.5')
            >>> list(zip(A, B))
            [(2, 1), (1.5, -1), (3, 2)]
            >>> fdot(_)
            mpf('6.5')
            >>> A = [2, 1.5, 3j]
            >>> B = [1+j, 3, -1-j]
            >>> fdot(A, B)
            mpc(real='9.5', imag='-1.0')
            >>> fdot(A, B, conjugate=True)
            mpc(real='3.5', imag='-5.0')

        """
        ...
    
    def mag(ctx, x):
        """
        Quick logarithmic magnitude estimate of a number. Returns an
        integer or infinity `m` such that `|x| <= 2^m`. It is not
        guaranteed that `m` is an optimal bound, but it will never
        be too large by more than 2 (and probably not more than 1).

        **Examples**

            >>> from mpmath import *
            >>> mp.pretty = True
            >>> mag(10), mag(10.0), mag(mpf(10)), int(ceil(log(10,2)))
            (4, 4, 4, 4)
            >>> mag(10j), mag(10+10j)
            (4, 5)
            >>> mag(0.01), int(ceil(log(0.01,2)))
            (-6, -6)
            >>> mag(0), mag(inf), mag(-inf), mag(nan)
            (-inf, +inf, +inf, nan)

        """
        ...
    


