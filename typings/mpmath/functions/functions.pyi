"""
This type stub file was generated by pyright.
"""

class SpecialFunctions:
    """
    This class implements special functions using high-level code.

    Elementary and some other functions (e.g. gamma function, basecase
    hypergeometric series) are assumed to be predefined by the context as
    "builtins" or "low-level" functions.
    """
    defined_functions = ...
    THETA_Q_LIM = ...
    def __init__(self) -> None:
        ...
    


def defun_wrapped(f):
    ...

def defun(f):
    ...

def defun_static(f):
    ...

@defun_wrapped
def cot(ctx, z):
    ...

@defun_wrapped
def sec(ctx, z):
    ...

@defun_wrapped
def csc(ctx, z):
    ...

@defun_wrapped
def coth(ctx, z):
    ...

@defun_wrapped
def sech(ctx, z):
    ...

@defun_wrapped
def csch(ctx, z):
    ...

@defun_wrapped
def acot(ctx, z):
    ...

@defun_wrapped
def asec(ctx, z):
    ...

@defun_wrapped
def acsc(ctx, z):
    ...

@defun_wrapped
def acoth(ctx, z):
    ...

@defun_wrapped
def asech(ctx, z):
    ...

@defun_wrapped
def acsch(ctx, z):
    ...

@defun
def sign(ctx, x):
    ...

@defun
def agm(ctx, a, b=...):
    ...

@defun_wrapped
def sinc(ctx, x):
    ...

@defun_wrapped
def sincpi(ctx, x):
    ...

@defun_wrapped
def expm1(ctx, x):
    ...

@defun_wrapped
def log1p(ctx, x):
    ...

@defun_wrapped
def powm1(ctx, x, y):
    ...

@defun
def root(ctx, x, n, k=...):
    ...

@defun
def unitroots(ctx, n, primitive=...): # -> list[Any]:
    ...

@defun
def arg(ctx, x):
    ...

@defun
def fabs(ctx, x):
    ...

@defun
def re(ctx, x):
    ...

@defun
def im(ctx, x):
    ...

@defun
def conj(ctx, x):
    ...

@defun
def polar(ctx, z): # -> tuple[Any, Any]:
    ...

@defun_wrapped
def rect(ctx, r, phi):
    ...

@defun
def log(ctx, x, b=...):
    ...

@defun
def log10(ctx, x):
    ...

@defun
def fmod(ctx, x, y):
    ...

@defun
def degrees(ctx, x):
    ...

@defun
def radians(ctx, x):
    ...

@defun
def lambertw(ctx, z, k=...): # -> complex | Any | float:
    ...

@defun_wrapped
def bell(ctx, n, x=...): # -> Any:
    ...

@defun_wrapped
def polyexp(ctx, s, z):
    ...

@defun_wrapped
def cyclotomic(ctx, n, z):
    ...

@defun
def mangoldt(ctx, n): # -> None:
    r"""
    Evaluates the von Mangoldt function `\Lambda(n) = \log p`
    if `n = p^k` a power of a prime, and `\Lambda(n) = 0` otherwise.

    **Examples**

        >>> from mpmath import *
        >>> mp.dps = 25; mp.pretty = True
        >>> [mangoldt(n) for n in range(-2,3)]
        [0.0, 0.0, 0.0, 0.0, 0.6931471805599453094172321]
        >>> mangoldt(6)
        0.0
        >>> mangoldt(7)
        1.945910149055313305105353
        >>> mangoldt(8)
        0.6931471805599453094172321
        >>> fsum(mangoldt(n) for n in range(101))
        94.04531122935739224600493
        >>> fsum(mangoldt(n) for n in range(10001))
        10013.39669326311478372032

    """
    ...

@defun
def stirling1(ctx, n, k, exact=...): # -> int:
    ...

@defun
def stirling2(ctx, n, k, exact=...): # -> int:
    ...

