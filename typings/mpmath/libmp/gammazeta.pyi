"""
This type stub file was generated by pyright.
"""

from .libelefun import constant_memo

"""
-----------------------------------------------------------------------
This module implements gamma- and zeta-related functions:

* Bernoulli numbers
* Factorials
* The gamma function
* Polygamma functions
* Harmonic numbers
* The Riemann zeta function
* Constants related to these functions

-----------------------------------------------------------------------
"""
@constant_memo
def catalan_fixed(prec): # -> int:
    ...

@constant_memo
def khinchin_fixed(prec):
    ...

@constant_memo
def glaisher_fixed(prec):
    ...

@constant_memo
def apery_fixed(prec): # -> int:
    ...

@constant_memo
def euler_fixed(prec):
    ...

@constant_memo
def mertens_fixed(prec):
    ...

@constant_memo
def twinprime_fixed(prec):
    ...

mpf_euler = ...
mpf_apery = ...
mpf_khinchin = ...
mpf_glaisher = ...
mpf_catalan = ...
mpf_mertens = ...
mpf_twinprime = ...
MAX_BERNOULLI_CACHE = ...
bernoulli_cache = ...
f3 = ...
f6 = ...
def bernoulli_size(n): # -> int:
    """Accurately estimate the size of B_n (even n > 2 only)"""
    ...

BERNOULLI_PREC_CUTOFF = ...
def mpf_bernoulli(n, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-1], Literal[1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]]:
    """Computation of Bernoulli numbers (numerically)"""
    ...

def mpf_bernoulli_huge(n, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]]:
    ...

def bernfrac(n): # -> tuple[int, int] | tuple[Literal[0], Literal[1]] | tuple[Any | None, int]:
    r"""
    Returns a tuple of integers `(p, q)` such that `p/q = B_n` exactly,
    where `B_n` denotes the `n`-th Bernoulli number. The fraction is
    always reduced to lowest terms. Note that for `n > 1` and `n` odd,
    `B_n = 0`, and `(0, 1)` is returned.

    **Examples**

    The first few Bernoulli numbers are exactly::

        >>> from mpmath import *
        >>> for n in range(15):
        ...     p, q = bernfrac(n)
        ...     print("%s %s/%s" % (n, p, q))
        ...
        0 1/1
        1 -1/2
        2 1/6
        3 0/1
        4 -1/30
        5 0/1
        6 1/42
        7 0/1
        8 -1/30
        9 0/1
        10 5/66
        11 0/1
        12 -691/2730
        13 0/1
        14 7/6

    This function works for arbitrarily large `n`::

        >>> p, q = bernfrac(10**4)
        >>> print(q)
        2338224387510
        >>> print(len(str(p)))
        27692
        >>> mp.dps = 15
        >>> print(mpf(p) / q)
        -9.04942396360948e+27677
        >>> print(bernoulli(10**4))
        -9.04942396360948e+27677

    .. note ::

        :func:`~mpmath.bernoulli` computes a floating-point approximation
        directly, without computing the exact fraction first.
        This is much faster for large `n`.

    **Algorithm**

    :func:`~mpmath.bernfrac` works by computing the value of `B_n` numerically
    and then using the von Staudt-Clausen theorem [1] to reconstruct
    the exact fraction. For large `n`, this is significantly faster than
    computing `B_1, B_2, \ldots, B_2` recursively with exact arithmetic.
    The implementation has been tested for `n = 10^m` up to `m = 6`.

    In practice, :func:`~mpmath.bernfrac` appears to be about three times
    slower than the specialized program calcbn.exe [2]

    **References**

    1. MathWorld, von Staudt-Clausen Theorem:
       http://mathworld.wolfram.com/vonStaudt-ClausenTheorem.html

    2. The Bernoulli Number Page:
       http://www.bernoulli.org/

    """
    ...

def mpf_harmonic(x, prec, rnd):
    ...

def mpc_harmonic(z, prec, rnd): # -> tuple[Any, tuple[Literal[0], int | Any, Literal[0], Literal[0]]] | tuple[Any, tuple[Literal[0], int | Any, Literal[0], Literal[0]] | Any | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Any | Literal[0], int | Any, Any | int, Any | Literal[0, 1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Any | int, Any | int, Any | int, Any | Literal[0, 1]] | tuple[Any, Any, Any, Any] | tuple[Literal[1, 0], Any, Any, Any | int]]:
    ...

def mpf_psi0(x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any, Any, Any, Any]:
    """
    Computation of the digamma function (psi function of order 0)
    of a real argument.
    """
    ...

def mpc_psi0(z, prec, rnd=...): # -> tuple[Any | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any, Any, Any, Any], tuple[Literal[0], int | Any, Literal[0], Literal[0]]] | tuple[Any, Any] | tuple[tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any | tuple[Any, Any, Any, Any] | tuple[Any | Literal[1, 0], int | Any, Any | int, Any | int], tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Any | Literal[0], int | Any, Any | int, Any | Literal[0, 1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Any | int, Any | int, Any | int, Any | Literal[0, 1]] | tuple[Any, Any, Any, Any] | tuple[Literal[1, 0], Any, Any, Any | int]]:
    """
    Computation of the digamma function (psi function of order 0)
    of a complex argument.
    """
    ...

def mpf_psi(m, x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any, Any, Any, Any] | tuple[Any | Literal[1, 0], int | Any, Any | int, Any | int]:
    """
    Computation of the polygamma function of arbitrary integer order
    m >= 0, for a real argument x.
    """
    ...

def mpc_psi(m, z, prec, rnd=...): # -> tuple[Any | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any, Any, Any, Any], tuple[Literal[0], int | Any, Literal[0], Literal[0]]] | tuple[Any, Any] | tuple[tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any | tuple[Any, Any, Any, Any] | tuple[Any | Literal[1, 0], int | Any, Any | int, Any | int], tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Any | Literal[0], int | Any, Any | int, Any | Literal[0, 1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Any | int, Any | int, Any | int, Any | Literal[0, 1]] | tuple[Any, Any, Any, Any] | tuple[Literal[1, 0], Any, Any, Any | int]] | tuple[tuple[Literal[0], int | Any, Literal[-123], Literal[-1]], tuple[Literal[0], int | Any, Literal[-123], Literal[-1]]] | tuple[tuple[Literal[0], int | Any, Literal[0], Literal[0]], tuple[Literal[0], int | Any, Literal[0], Literal[0]]] | tuple[tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | Any | tuple[Any, Any, Any, Any] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]], tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | Any | tuple[Any, Any, Any, Any] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]]:
    """
    Computation of the polygamma function of arbitrary integer order
    m >= 0, for a complex argument z.
    """
    ...

borwein_cache = ...
def borwein_coefficients(n):
    ...

ZETA_INT_CACHE_MAX_PREC = ...
zeta_int_cache = ...
def mpf_zeta_int(s, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-1], Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1, 0], Any, Any, Any | int]:
    """
    Optimized computation of zeta(s) for an integer s.
    """
    ...

def mpf_zeta(s, prec, rnd=..., alt=...): # -> tuple[Literal[0], int | Any, Literal[-1], Literal[1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-1], Literal[1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[0], Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1, 0], Any, Any, Any | int]:
    ...

def mpc_zeta(s, prec, rnd=..., alt=..., force=...): # -> tuple[tuple[Literal[0], int | Any, Literal[-1], Literal[1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-1], Literal[1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any | tuple[Literal[0], int | Any, Literal[0], Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1, 0], Any, Any, Any | int], tuple[Literal[0], int | Any, Literal[0], Literal[0]]] | tuple[Any | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]], Any | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]] | tuple[Any, Any] | tuple[tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any, tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any]:
    ...

def mpf_altzeta(s, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-1], Literal[1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-1], Literal[1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[0], Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1, 0], Any, Any, Any | int]:
    ...

def mpc_altzeta(s, prec, rnd=...): # -> tuple[tuple[Literal[0], int | Any, Literal[-1], Literal[1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-1], Literal[1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any | tuple[Literal[0], int | Any, Literal[0], Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1, 0], Any, Any, Any | int], tuple[Literal[0], int | Any, Literal[0], Literal[0]]] | tuple[Any | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]], Any | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]] | tuple[Any, Any] | tuple[tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any, tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any]:
    ...

mpf_zetasum = ...
def pow_fixed(x, n, wp):
    ...

sieve_cache = ...
primes_cache = ...
mult_cache = ...
def primesieve(n): # -> tuple[list[Any], list[Any], list[Any]] | tuple[Any, list[int], Any]:
    ...

def zetasum_sieved(critical_line, sre, sim, a, n, wp): # -> tuple[Any | int, int | Any]:
    ...

ZETASUM_SIEVE_CUTOFF = ...
def mpc_zetasum(s, a, n, derivatives, reflect, prec): # -> tuple[list[tuple[tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any, tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any]], list[Any]] | tuple[list[tuple[tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any, tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any]], list[tuple[tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any, tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any]]]:
    """
    Fast version of mp._zetasum, assuming s = complex, a = integer.
    """
    ...

MAX_GAMMA_TAYLOR_PREC = ...
GAMMA_STIRLING_BETA = ...
SMALL_FACTORIAL_CACHE_SIZE = ...
gamma_taylor_cache = ...
gamma_stirling_cache = ...
small_factorial_cache = ...
def zeta_array(N, prec): # -> list[Any]:
    """
    zeta(n) = A * pi**n / n! + B

    where A is a rational number (A = Bernoulli number
    for n even) and B is an infinite sum over powers of exp(2*pi).
    (B = 0 for n even).

    TODO: this is currently only used for gamma, but could
    be very useful elsewhere.
    """
    ...

def gamma_taylor_coefficients(inprec): # -> tuple[Any, Any] | tuple[list[Any], Any]:
    """
    Gives the Taylor coefficients of 1/gamma(1+x) as
    a list of fixed-point numbers. Enough coefficients are returned
    to ensure that the series converges to the given precision
    when x is in [0.5, 1.5].
    """
    ...

def gamma_fixed_taylor(xmpf, x, wp, prec, rnd, type): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any | Literal[0, 1], int | Any, Any, Any | Literal[-1, 0, -2, -3, 1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Any, Any, Any, Any] | tuple[Any | int, int | Any, Any | Literal[-789, -456, -123, 0], Any | int] | None:
    ...

def stirling_coefficient(n):
    ...

def real_stirling_series(x, prec):
    """
    Sums the rational part of Stirling's expansion,

    log(sqrt(2*pi)) - z + 1/(12*z) - 1/(360*z^3) + ...

    """
    ...

def complex_stirling_series(x, y, prec): # -> tuple[Any, Any]:
    ...

def mpf_gamma(x, prec, rnd=..., type=...):
    """
    This function implements multipurpose evaluation of the gamma
    function, G(x), as well as the following versions of the same:

    type = 0 -- G(x)                    [standard gamma function]
    type = 1 -- G(x+1) = x*G(x+1) = x!  [factorial]
    type = 2 -- 1/G(x)                  [reciprocal gamma function]
    type = 3 -- log(|G(x)|)             [log-gamma function, real part]
    """
    ...

def mpc_gamma(z, prec, rnd=..., type=...):
    ...

def mpf_factorial(x, prec, rnd=...):
    ...

def mpc_factorial(x, prec, rnd=...):
    ...

def mpf_rgamma(x, prec, rnd=...):
    ...

def mpc_rgamma(x, prec, rnd=...):
    ...

def mpf_loggamma(x, prec, rnd=...):
    ...

def mpc_loggamma(z, prec, rnd=...): # -> tuple[Any, tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]]]:
    ...

def mpf_gamma_int(n, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    ...

