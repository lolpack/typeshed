"""
This type stub file was generated by pyright.
"""

from .backend import BACKEND
from .libmpf import mpf_sqrt

"""
This module implements computation of elementary transcendental
functions (powers, logarithms, trigonometric and hyperbolic
functions, inverse trigonometric and hyperbolic) for real
floating-point numbers.

For complex and interval implementations of the same functions,
see libmpc and libmpi.

"""
if BACKEND == 'python':
    EXP_COSH_CUTOFF = ...
else:
    EXP_COSH_CUTOFF = ...
EXP_SERIES_U_CUTOFF = ...
if BACKEND == 'python':
    COS_SIN_CACHE_PREC = ...
else:
    COS_SIN_CACHE_PREC = ...
COS_SIN_CACHE_STEP = ...
cos_sin_cache = ...
MAX_LOG_INT_CACHE = ...
log_int_cache = ...
LOG_TAYLOR_PREC = ...
LOG_TAYLOR_SHIFT = ...
log_taylor_cache = ...
LOG_AGM_MAG_PREC_RATIO = ...
ATAN_TAYLOR_PREC = ...
ATAN_TAYLOR_SHIFT = ...
atan_taylor_cache = ...
cache_prec_steps = ...
def constant_memo(f): # -> Callable[..., Any]:
    """
    Decorator for caching computed values of mathematical
    constants. This decorator should be applied to a
    function taking a single argument prec as input and
    returning a fixed-point value with the given precision.
    """
    ...

def def_mpf_constant(fixed): # -> Callable[..., tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any]:
    """
    Create a function that computes the mpf value for a mathematical
    constant, given a function that computes the fixed-point value.

    Assumptions: the constant is positive and has magnitude ~= 1;
    the fixed-point function rounds to floor.
    """
    ...

def bsp_acot(q, a, b, hyperbolic): # -> tuple[int | Any, Any, Any] | tuple[Any, Any, Any]:
    ...

def acot_fixed(a, prec, hyperbolic):
    """
    Compute acot(a) or acoth(a) for an integer a with binary splitting; see
    http://numbers.computation.free.fr/Constants/Algorithms/splitting.html
    """
    ...

def machin(coefs, prec, hyperbolic=...): # -> int:
    """
    Evaluate a Machin-like formula, i.e., a linear combination of
    acot(n) or acoth(n) for specific integer values of n, using fixed-
    point arithmetic. The input should be a list [(c, n), ...], giving
    c*acot[h](n) + ...
    """
    ...

@constant_memo
def ln2_fixed(prec): # -> int:
    """
    Computes ln(2). This is done with a hyperbolic Machin-type formula,
    with binary splitting at high precision.
    """
    ...

@constant_memo
def ln10_fixed(prec): # -> int:
    """
    Computes ln(10). This is done with a hyperbolic Machin-type formula.
    """
    ...

CHUD_A = ...
CHUD_B = ...
CHUD_C = ...
CHUD_D = ...
def bs_chudnovsky(a, b, level, verbose): # -> tuple[Any, Any, Any]:
    """
    Computes the sum from a to b of the series in the Chudnovsky
    formula. Returns g, p, q where p/q is the sum as an exact
    fraction and g is a temporary value used to save work
    for recursive calls.
    """
    ...

@constant_memo
def pi_fixed(prec, verbose=..., verbose_base=...):
    """
    Compute floor(pi * 2**prec) as a big integer.

    This is done using Chudnovsky's series (see comments in
    libelefun.py for details).
    """
    ...

def degree_fixed(prec):
    ...

def bspe(a, b): # -> tuple[int | Any, Any] | tuple[Any, Any]:
    """
    Sum series for exp(1)-1 between a, b, returning the result
    as an exact fraction (p, q).
    """
    ...

@constant_memo
def e_fixed(prec):
    """
    Computes exp(1). This is done using the ordinary Taylor series for
    exp, with binary splitting. For a description of the algorithm,
    see:

        http://numbers.computation.free.fr/Constants/
            Algorithms/splitting.html
    """
    ...

@constant_memo
def phi_fixed(prec):
    """
    Computes the golden ratio, (1+sqrt(5))/2
    """
    ...

mpf_phi = ...
mpf_pi = ...
mpf_e = ...
mpf_degree = ...
mpf_ln2 = ...
mpf_ln10 = ...
@constant_memo
def ln_sqrt2pi_fixed(prec):
    ...

@constant_memo
def sqrtpi_fixed(prec): # -> int | Any:
    ...

mpf_sqrtpi = ...
mpf_ln_sqrt2pi = ...
def mpf_pow(s, t, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Literal[0], int | Any, Literal[0], Literal[1]]:
    """
    Compute s**t. Raises ComplexResult if s is negative and t is
    fractional.
    """
    ...

def int_pow_fixed(y, n, prec): # -> tuple[Any, Literal[0]] | tuple[Any | int, Any | int]:
    """n-th power of a fixed point number with precision prec

       Returns the power in the form man, exp,
       man * 2**exp ~= y**n
    """
    ...

def nthroot_fixed(y, n, prec, exp1): # -> None:
    ...

def mpf_nthroot(s, n, prec, rnd=...):
    """nth-root of a positive number

    Use the Newton method when faster, otherwise use x**(1/n)
    """
    ...

def mpf_cbrt(s, prec, rnd=...):
    """cubic root of a positive number"""
    ...

def log_int_fixed(n, prec, ln2=...):
    """
    Fast computation of log(n), caching the value for small n,
    intended for zeta sums.
    """
    ...

def agm_fixed(a, b, prec):
    """
    Fixed-point computation of agm(a,b), assuming
    a, b both close to unit magnitude.
    """
    ...

def log_agm(x, prec):
    """
    Fixed-point computation of -log(x) = log(1/x), suitable
    for large precision. It is required that 0 < x < 1. The
    algorithm used is the Sasaki-Kanada formula

        -log(x) = pi/agm(theta2(x)^2,theta3(x)^2). [1]

    For faster convergence in the theta functions, x should
    be chosen closer to 0.

    Guard bits must be added by the caller.

    HYPOTHESIS: if x = 2^(-n), n bits need to be added to
    account for the truncation to a fixed-point number,
    and this is the only significant cancellation error.

    The number of bits lost to roundoff is small and can be
    considered constant.

    [1] Richard P. Brent, "Fast Algorithms for High-Precision
        Computation of Elementary Functions (extended abstract)",
        http://wwwmaths.anu.edu.au/~brent/pd/RNC7-Brent.pdf

    """
    ...

def log_taylor(x, prec, r=...):
    """
    Fixed-point calculation of log(x). It is assumed that x is close
    enough to 1 for the Taylor series to converge quickly. Convergence
    can be improved by specifying r > 0 to compute
    log(x^(1/2^r))*2^r, at the cost of performing r square roots.

    The caller must provide sufficient guard bits.
    """
    ...

def log_taylor_cached(x, prec):
    """
    Fixed-point computation of log(x), assuming x in (0.5, 2)
    and prec <= LOG_TAYLOR_PREC.
    """
    ...

def mpf_log(x, prec, rnd=...): # -> tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any, Any, Any, Any]:
    """
    Compute the natural logarithm of the mpf value x. If x is negative,
    ComplexResult is raised.
    """
    ...

def mpf_log_hypot(a, b, prec, rnd): # -> tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any, Any, Any, Any] | tuple[Any | Literal[1, 0], int | Any, Any | int, Any | int]:
    """
    Computes log(sqrt(a^2+b^2)) accurately.
    """
    ...

def atan_newton(x, prec):
    ...

def atan_taylor_get_cached(n, prec): # -> tuple[Any, Any]:
    ...

def atan_taylor(x, prec):
    ...

def atan_inf(sign, prec, rnd): # -> tuple[Any | Literal[0], int | Any, Any | int, Any | Literal[0, 1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Any | int, Any | int, Any | int, Any | Literal[0, 1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    ...

def mpf_atan(x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any | Literal[0], int | Any, Any | int, Any | Literal[0, 1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Any | int, Any | int, Any | int, Any | Literal[0, 1]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1, 0], Any, Any, Any | int]:
    ...

def mpf_atan2(y, x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Any | Literal[0], int | Any, Any | int, Any | Literal[0, 1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Any | int, Any | int, Any | int, Any | Literal[0, 1]] | tuple[Any, Any, Any, Any] | tuple[Literal[1, 0], Any, Any, Any | int]:
    ...

def mpf_asin(x, prec, rnd=...): # -> tuple[Any | int, int | Any, Any | int, Any | int]:
    ...

def mpf_acos(x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any | int, int | Any, Any | int, Any | int]:
    ...

def mpf_asinh(x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Any | int, int | Any, Any | Literal[-789, -456, -123, 0], Any | int] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1, 0], Any, Any, Any | int]:
    ...

def mpf_acosh(x, prec, rnd=...): # -> tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any, Any, Any, Any]:
    ...

def mpf_atanh(x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any | Literal[1, 0], int | Any, Any | int, Any | int]:
    ...

def mpf_fibonacci(x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any]:
    ...

def exponential_series(x, prec, type=...): # -> tuple[Any, Any | int]:
    """
    Taylor series for cosh/sinh or cos/sin.

    type = 0 -- returns exp(x)  (slightly faster than cosh+sinh)
    type = 1 -- returns (cosh(x), sinh(x))
    type = 2 -- returns (cos(x), sin(x))
    """
    ...

def exp_basecase(x, prec): # -> tuple[Any, Any | int]:
    """
    Compute exp(x) as a fixed-point number. Works for any x,
    but for speed should have |x| < 1. For an arbitrary number,
    use exp(x) = exp(x-m*log(2)) * 2^m where m = floor(x/log(2)).
    """
    ...

def exp_expneg_basecase(x, prec): # -> tuple[Any, Any] | tuple[Any | tuple[Any, Any | int], Any]:
    """
    Computation of exp(x), exp(-x)
    """
    ...

def cos_sin_basecase(x, prec): # -> tuple[Any, Any | int] | tuple[Any, Any]:
    """
    Compute cos(x), sin(x) as fixed-point numbers, assuming x
    in [0, pi/2). For an arbitrary number, use x' = x - m*(pi/2)
    where m = floor(x/(pi/2)) along with quarter-period symmetries.
    """
    ...

def mpf_exp(x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Literal[0], int | Any, Literal[0], Literal[1]]:
    ...

def mpf_cosh_sinh(x, prec, rnd=..., tanh=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[1]] | tuple[Literal[1], int | Any, Literal[0], Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[tuple[Literal[0], int | Any, Literal[-456], Literal[-2]], tuple[Literal[0], int | Any, Literal[-456], Literal[-2]]] | tuple[tuple[Literal[0], int | Any, Literal[-456], Literal[-2]], tuple[Literal[1], int | Any, Literal[-789], Literal[-3]]] | tuple[tuple[Literal[0], int | Any, Literal[-123], Literal[-1]], tuple[Literal[0], int | Any, Literal[-123], Literal[-1]]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]], Any | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]] | tuple[Any | tuple[Any | Literal[0, 1], Any | int, Any | int, Any | int], tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | Any | tuple[Any | int, Any | int, Any | int, Any | int] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any | Literal[0, 1], Any | int, Any | int, Any | int]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any, tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any]:
    """Simultaneously compute (cosh(x), sinh(x)) for real x"""
    ...

def mod_pi2(man, exp, mag, wp): # -> tuple[Any, int | Any, Any]:
    ...

def mpf_cos_sin(x, prec, rnd=..., which=..., pi=...):
    """
    which:
    0 -- return cos(x), sin(x)
    1 -- return cos(x)
    2 -- return sin(x)
    3 -- return tan(x)

    if pi=True, compute for pi*x
    """
    ...

def mpf_cos(x, prec, rnd=...):
    ...

def mpf_sin(x, prec, rnd=...):
    ...

def mpf_tan(x, prec, rnd=...):
    ...

def mpf_cos_sin_pi(x, prec, rnd=...):
    ...

def mpf_cos_pi(x, prec, rnd=...):
    ...

def mpf_sin_pi(x, prec, rnd=...):
    ...

def mpf_cosh(x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any | Literal[0, 1], Any | int, Any | int, Any | int] | tuple[Literal[1, 0], Any, Any, Any | int] | Literal[0, 1]:
    ...

def mpf_sinh(x, prec, rnd=...): # -> int | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any | int, Any | int, Any | int, Any | int] | tuple[Any | Literal[0, 1], Any | int, Any | int, Any | int] | tuple[Literal[1, 0], Any, Any, Any | int]:
    ...

def mpf_tanh(x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[1]] | tuple[Literal[1], int | Any, Literal[0], Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[tuple[Literal[0], int | Any, Literal[-456], Literal[-2]], tuple[Literal[0], int | Any, Literal[-456], Literal[-2]]] | tuple[tuple[Literal[0], int | Any, Literal[-456], Literal[-2]], tuple[Literal[1], int | Any, Literal[-789], Literal[-3]]] | tuple[tuple[Literal[0], int | Any, Literal[-123], Literal[-1]], tuple[Literal[0], int | Any, Literal[-123], Literal[-1]]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]], Any | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]] | tuple[Any | tuple[Any | Literal[0, 1], Any | int, Any | int, Any | int], tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | Any | tuple[Any | int, Any | int, Any | int, Any | int] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Any | Literal[0, 1], Any | int, Any | int, Any | int]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any, tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | Any]:
    ...

def cos_sin_fixed(x, prec, pi2=...): # -> tuple[Any, Any | int] | tuple[Any | int, Any] | None:
    ...

def exp_fixed(x, prec, ln2=...):
    ...

if BACKEND == 'sage':
    mpf_sqrt = ...
    mpf_exp = ...
    mpf_log = ...
    mpf_cos = ...
    mpf_sin = ...
    mpf_pow = ...
    exp_fixed = ...
    cos_sin_fixed = ...
    log_int_fixed = ...
