"""
This type stub file was generated by pyright.
"""

from .backend import BACKEND, gmpy

"""
Utility functions for integer math.

TODO: rename, cleanup, perhaps move the gmpy wrapper code
here from settings.py

"""
small_trailing = ...
def giant_steps(start, target, n=...): # -> list[Any]:
    """
    Return a list of integers ~=

    [start, n*start, ..., target/n^2, target/n, target]

    but conservatively rounded so that the quotient between two
    successive elements is actually slightly less than n.

    With n = 2, this describes suitable precision steps for a
    quadratically convergent algorithm such as Newton's method;
    with n = 3 steps for cubic convergence (Halley's method), etc.

        >>> giant_steps(50,1000)
        [66, 128, 253, 502, 1000]
        >>> giant_steps(50,1000,4)
        [65, 252, 1000]

    """
    ...

def rshift(x, n):
    """For an integer x, calculate x >> n with the fastest (floor)
    rounding. Unlike the plain Python expression (x >> n), n is
    allowed to be negative, in which case a left shift is performed."""
    ...

def lshift(x, n):
    """For an integer x, calculate x << n. Unlike the plain Python
    expression (x << n), n is allowed to be negative, in which case a
    right shift with default (floor) rounding is performed."""
    ...

if BACKEND == 'sage':
    rshift = ...
    lshift = ...
def python_trailing(n): # -> Literal[0]:
    """Count the number of trailing zero bits in abs(n)."""
    ...

if BACKEND == 'gmpy':
    ...
powers = ...
def python_bitcount(n): # -> int:
    """Calculate bit size of the nonnegative integer n."""
    ...

def gmpy_bitcount(n): # -> Literal[0]:
    """Calculate bit size of the nonnegative integer n."""
    ...

def sage_trailing(n):
    ...

if BACKEND == 'gmpy':
    bitcount = ...
    trailing = ...
else:
    sage_bitcount = ...
    bitcount = ...
    trailing = ...
    bitcount = ...
    trailing = ...
if BACKEND == 'gmpy' and 'bit_length' in dir(gmpy):
    bitcount = ...
trailtable = ...
bctable = ...
def bin_to_radix(x, xbits, base, bdigits):
    """Changes radix of a fixed-point number; i.e., converts
    x * 2**xbits to floor(x * 10**bdigits)."""
    ...

stddigits = ...
def small_numeral(n, base=..., digits=...): # -> str | LiteralString:
    """Return the string numeral of a positive integer in an arbitrary
    base. Most efficient for small input."""
    ...

def numeral_python(n, base=..., size=..., digits=...): # -> str | LiteralString:
    """Represent the integer n as a string of digits in the given base.
    Recursive division is used to make this function about 3x faster
    than Python's str() for converting integers to decimal strings.

    The 'size' parameters specifies the number of digits in n; this
    number is only used to determine splitting points and need not be
    exact."""
    ...

def numeral_gmpy(n, base=..., size=..., digits=...):
    """Represent the integer n as a string of digits in the given base.
    Recursive division is used to make this function about 3x faster
    than Python's str() for converting integers to decimal strings.

    The 'size' parameters specifies the number of digits in n; this
    number is only used to determine splitting points and need not be
    exact."""
    ...

if BACKEND == "gmpy":
    numeral = ...
else:
    numeral = ...
_1_800 = ...
_1_600 = ...
_1_400 = ...
_1_200 = ...
_1_100 = ...
_1_50 = ...
def isqrt_small_python(x): # -> int | None:
    """
    Correctly (floor) rounded integer square root, using
    division. Fast up to ~200 digits.
    """
    ...

def isqrt_fast_python(x): # -> int:
    """
    Fast approximate integer square root, computed using division-free
    Newton iteration for large x. For random integers the result is almost
    always correct (floor(sqrt(x))), but is 1 ulp too small with a roughly
    0.1% probability. If x is very close to an exact square, the answer is
    1 ulp wrong with high probability.

    With 0 guard bits, the largest error over a set of 10^5 random
    inputs of size 1-10^5 bits was 3 ulp. The use of 10 guard bits
    almost certainly guarantees a max 1 ulp error.
    """
    ...

def sqrtrem_python(x): # -> tuple[Any | int | None, Any] | tuple[Any | int, Any]:
    """Correctly rounded integer (floor) square root with remainder."""
    ...

def isqrt_python(x): # -> int | None:
    """Integer square root with correct (floor) rounding."""
    ...

def sqrt_fixed(x, prec): # -> int | Any:
    ...

sqrt_fixed2 = ...
if BACKEND == 'gmpy':
    ...
else:
    isqrt = ...
    sqrtrem = ...
    isqrt_small = ...
    isqrt_fast = ...
    isqrt = ...
    sqrtrem = ...
def ifib(n, _cache=...): # -> int:
    """Computes the nth Fibonacci number as an integer, for
    integer n."""
    ...

MAX_FACTORIAL_CACHE = ...
def ifac(n, memo=...):
    """Return n factorial (for integers n >= 0 only)."""
    ...

def ifac2(n, memo_pair=...):
    """Return n!! (double factorial), integers n >= 0 only."""
    ...

if BACKEND == 'gmpy':
    ifac = ...
else:
    ifac = ...
    ifib = ...
def list_primes(n): # -> list[int]:
    ...

if BACKEND == 'sage':
    def list_primes(n): # -> list[int]:
        ...
    
small_odd_primes = ...
small_odd_primes_set = ...
def isprime(n): # -> bool:
    """
    Determines whether n is a prime number. A probabilistic test is
    performed if n is very large. No special trick is used for detecting
    perfect powers.

        >>> sum(list_primes(100000))
        454396537
        >>> sum(n*isprime(n) for n in range(100000))
        454396537

    """
    ...

def moebius(n): # -> int | Any:
    """
    Evaluates the Moebius function which is `mu(n) = (-1)^k` if `n`
    is a product of `k` distinct primes and `mu(n) = 0` otherwise.

    TODO: speed up using factorization
    """
    ...

def gcd(*args): # -> Literal[0]:
    ...

MAX_EULER_CACHE = ...
def eulernum(m, _cache=...): # -> int | Any | None:
    r"""
    Computes the Euler numbers `E(n)`, which can be defined as
    coefficients of the Taylor expansion of `1/cosh x`:

    .. math ::

        \frac{1}{\cosh x} = \sum_{n=0}^\infty \frac{E_n}{n!} x^n

    Example::

        >>> [int(eulernum(n)) for n in range(11)]
        [1, 0, -1, 0, 5, 0, -61, 0, 1385, 0, -50521]
        >>> [int(eulernum(n)) for n in range(11)]   # test cache
        [1, 0, -1, 0, 5, 0, -61, 0, 1385, 0, -50521]

    """
    ...

def stirling1(n, k): # -> int:
    """
    Stirling number of the first kind.
    """
    ...

def stirling2(n, k): # -> int:
    """
    Stirling number of the second kind.
    """
    ...

