"""
This type stub file was generated by pyright.
"""

from .backend import BACKEND, STRICT, gmpy

"""
Low-level functions for arbitrary-precision floating-point arithmetic.
"""
__docformat__ = ...
getrandbits = ...
if BACKEND == 'sage':
    def to_pickable(x): # -> tuple[Any, str, Any, Any]:
        ...
    
else:
    def to_pickable(x): # -> tuple[Any, str, Any, Any]:
        ...
    
def from_pickable(x): # -> tuple[Any, Any, Any, Any]:
    ...

class ComplexResult(ValueError):
    ...


round_nearest = ...
round_floor = ...
round_ceiling = ...
round_up = ...
round_down = ...
round_fast = ...
def prec_to_dps(n): # -> int:
    """Return number of accurate decimals that can be represented
    with a precision of n bits."""
    ...

def dps_to_prec(n): # -> int:
    """Return the number of bits required to represent n decimals
    accurately."""
    ...

def repr_dps(n): # -> int:
    """Return the number of decimal digits required to represent
    a number with n-bit precision so that it can be uniquely
    reconstructed from the representation."""
    ...

fzero = ...
fnzero = ...
fone = ...
fnone = ...
ftwo = ...
ften = ...
fhalf = ...
fnan = ...
finf = ...
fninf = ...
math_float_inf = ...
def round_int(x, n, rnd): # -> None:
    ...

class h_mask_big:
    def __getitem__(self, n):
        ...
    


h_mask_small = ...
h_mask = ...
shifts_down = ...
_exp_types = ...
def strict_normalize(sign, man, exp, bc, prec, rnd): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Additional checks on the components of an mpf. Enable tests by setting
       the environment variable MPMATH_STRICT to Y."""
    ...

def strict_normalize1(sign, man, exp, bc, prec, rnd): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Additional checks on the components of an mpf. Enable tests by setting
       the environment variable MPMATH_STRICT to Y."""
    ...

if BACKEND == 'gmpy' and '_mpmath_normalize' in dir(gmpy):
    _normalize = ...
    _normalize1 = ...
if BACKEND == 'sage':
    _normalize1 = ...
if STRICT:
    normalize = ...
    normalize1 = ...
else:
    normalize = ...
    normalize1 = ...
def from_man_exp(man, exp, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Create raw mpf from (man, exp) pair. The mantissa may be signed.
    If no precision is specified, the mantissa is stored exactly."""
    ...

int_cache = ...
if BACKEND == 'gmpy' and '_mpmath_create' in dir(gmpy):
    from_man_exp = ...
if BACKEND == 'sage':
    from_man_exp = ...
def from_int(n, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Create a raw mpf from an integer. If no precision is specified,
    the mantissa is stored exactly."""
    ...

def to_man_exp(s): # -> tuple[Any, Any]:
    """Return (man, exp) of a raw mpf. Raise an error if inf/nan."""
    ...

def to_int(s, rnd=...): # -> None:
    """Convert a raw mpf to the nearest int. Rounding is done down by
    default (same as int(float) in Python), but can be changed. If the
    input is inf/nan, an exception is raised."""
    ...

def mpf_round_int(s, rnd): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[0], int | Any, Literal[0], Literal[1]] | tuple[Literal[1], int | Any, Literal[0], Literal[1]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    ...

def mpf_floor(s, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[0], Literal[1]] | tuple[Literal[1], int | Any, Literal[0], Literal[1]]:
    ...

def mpf_ceil(s, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[0], Literal[1]] | tuple[Literal[1], int | Any, Literal[0], Literal[1]]:
    ...

def mpf_nint(s, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[0], Literal[1]] | tuple[Literal[1], int | Any, Literal[0], Literal[1]]:
    ...

def mpf_frac(s, prec=..., rnd=...):
    ...

def from_float(x, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Create a raw mpf from a Python float, rounding if necessary.
    If prec >= 53, the result is guaranteed to represent exactly the
    same number as the input. If prec is not specified, use prec=53."""
    ...

def from_npfloat(x, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Create a raw mpf from a numpy float, rounding if necessary.
    If prec >= 113, the result is guaranteed to represent exactly the
    same number as the input. If prec is not specified, use prec=113."""
    ...

def from_Decimal(x, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[1, 0], Any, Any, Any | int]:
    """Create a raw mpf from a Decimal, rounding if necessary.
    If prec is not specified, use the equivalent bit precision
    of the number of significant digits in x."""
    ...

def to_float(s, strict=..., rnd=...): # -> float:
    """
    Convert a raw mpf to a Python float. The result is exact if the
    bitcount of s is <= 53 and no underflow/overflow occurs.

    If the number is too large or too small to represent as a regular
    float, it will be converted to inf or 0.0. Setting strict=True
    forces an OverflowError to be raised instead.

    Warning: with a directed rounding mode, the correct nearest representable
    floating-point number in the specified direction might not be computed
    in case of overflow or (gradual) underflow.
    """
    ...

def from_rational(p, q, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Create a raw mpf from a rational number p/q, round if
    necessary."""
    ...

def to_rational(s): # -> tuple[Any, Literal[1]] | tuple[Any, Any]:
    """Convert a raw mpf to a rational number. Return integers (p, q)
    such that s = p/q exactly."""
    ...

def to_fixed(s, prec):
    """Convert a raw mpf to a fixed-point big integer"""
    ...

def mpf_rand(prec): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Return a raw mpf chosen randomly from [0, 1), with prec bits
    in the mantissa."""
    ...

def mpf_eq(s, t): # -> Literal[False]:
    """Test equality of two raw mpfs. This is simply tuple comparison
    unless either number is nan, in which case the result is False."""
    ...

def mpf_hash(s): # -> int:
    ...

def mpf_cmp(s, t): # -> int:
    """Compare the raw mpfs s and t. Return -1 if s < t, 0 if s == t,
    and 1 if s > t. (Same convention as Python's cmp() function.)"""
    ...

def mpf_lt(s, t): # -> bool:
    ...

def mpf_le(s, t): # -> bool:
    ...

def mpf_gt(s, t): # -> bool:
    ...

def mpf_ge(s, t): # -> bool:
    ...

def mpf_min_max(seq): # -> tuple[Any, Any]:
    ...

def mpf_pos(s, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Calculate 0+s for a raw mpf (i.e., just round s to the specified
    precision)."""
    ...

def mpf_neg(s, prec=..., rnd=...): # -> tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Any, Any, Any, Any] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Negate a raw mpf (return -s), rounding the result to the
    specified precision. The prec argument can be omitted to do the
    operation exactly."""
    ...

def mpf_abs(s, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], Any, Any, Any] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Return abs(s) of the raw mpf s, rounded to the specified
    precision. The prec argument can be omitted to generate an
    exact result."""
    ...

def mpf_sign(s): # -> Literal[1, -1, 0]:
    """Return -1, 0, or 1 (as a Python int, not a raw mpf) depending on
    whether s is negative, zero, or positive. (Nan is taken to give 0.)"""
    ...

def mpf_add(s, t, prec=..., rnd=..., _sub=...):
    """
    Add the two raw mpf values s and t.

    With prec=0, no rounding is performed. Note that this can
    produce a very large mantissa (potentially too large to fit
    in memory) if exponents are far apart.
    """
    ...

def mpf_sub(s, t, prec=..., rnd=...):
    """Return the difference of two raw mpfs, s-t. This function is
    simply a wrapper of mpf_add that changes the sign of t."""
    ...

def mpf_sum(xs, prec=..., rnd=..., absolute=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[1, 0], Any, Any, Any | int] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """
    Sum a list of mpf values efficiently and accurately
    (typically no temporary roundoff occurs). If prec=0,
    the final result will not be rounded either.

    There may be roundoff error or cancellation if extremely
    large exponent differences occur.

    With absolute=True, sums the absolute values.
    """
    ...

def gmpy_mpf_mul(s, t, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]]:
    """Multiply two raw mpfs"""
    ...

def gmpy_mpf_mul_int(s, n, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]]:
    """Multiply by a Python integer."""
    ...

def python_mpf_mul(s, t, prec=..., rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]]:
    """Multiply two raw mpfs"""
    ...

def python_mpf_mul_int(s, n, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]]:
    """Multiply by a Python integer."""
    ...

if BACKEND == 'gmpy':
    mpf_mul = ...
    mpf_mul_int = ...
else:
    mpf_mul = ...
    mpf_mul_int = ...
def mpf_shift(s, n): # -> tuple[Any, Any, Any, Any]:
    """Quickly multiply the raw mpf s by 2**n without rounding."""
    ...

def mpf_frexp(x): # -> tuple[tuple[Literal[0], int | Any, Literal[0], Literal[0]], Literal[0]] | tuple[Any | tuple[Any, Any, Any, Any], Any]:
    """Convert x = y*2**n to (y, n) with abs(y) in [0.5, 1) if nonzero"""
    ...

def mpf_div(s, t, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Floating-point division"""
    ...

def mpf_rdiv_int(n, t, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """Floating-point division n/t with a Python integer as numerator"""
    ...

def mpf_mod(s, t, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    ...

reciprocal_rnd = ...
negative_rnd = ...
def mpf_pow_int(s, n, prec, rnd=...):
    """Compute s**n, where s is a raw mpf and n is a Python integer."""
    ...

def mpf_perturb(x, eps_sign, prec, rnd): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    """
    For nonzero x, calculate x + eps with directed rounding, where
    eps < prec relatively and eps has the given sign (0 for
    positive, 1 for negative).

    With rounding to nearest, this is taken to simply normalize
    x to the given precision.
    """
    ...

def to_digits_exp(s, dps): # -> tuple[Literal[''], Literal['0'], Literal[0]] | tuple[Literal['-', ''], Any | str | LiteralString, Any | int]:
    """Helper function for representing the floating-point number s as
    a decimal with dps digits. Returns (sign, string, exponent) where
    sign is '' or '-', string is the digit string, and exponent is
    the decimal exponent as an int.

    If inexact, the decimal representation is rounded toward zero."""
    ...

def to_str(s, dps, strip_zeros=..., min_fixed=..., max_fixed=..., show_zero_exponent=...):
    """
    Convert a raw mpf to a decimal floating-point literal with at
    most `dps` decimal digits in the mantissa (not counting extra zeros
    that may be inserted for visual purposes).

    The number will be printed in fixed-point format if the position
    of the leading digit is strictly between min_fixed
    (default = min(-dps/3,-5)) and max_fixed (default = dps).

    To force fixed-point format always, set min_fixed = -inf,
    max_fixed = +inf. To force floating-point format, set
    min_fixed >= max_fixed.

    The literal is formatted so that it can be parsed back to a number
    by to_str, float() or Decimal().
    """
    ...

def str_to_man_exp(x, base=...): # -> tuple[Any, int]:
    """Helper function for from_str."""
    ...

special_str = ...
def from_str(x, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[1], int | Any, Literal[-789], Literal[-3]] | tuple[Literal[0], int | Any, Literal[-123], Literal[-1]] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[1, 0], Any, Any, Any | int]:
    """Create a raw mpf from a decimal literal, rounding in the
    specified direction if the input number cannot be represented
    exactly as a binary floating-point number with the given number of
    bits. The literal syntax accepted is the same as for Python
    floats.

    TODO: the rounding does not work properly for large exponents.
    """
    ...

def from_bstr(x): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]]:
    ...

def to_bstr(x):
    ...

def mpf_sqrt(s, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[1, 0], Any, Any, Any | int]:
    """
    Compute the square root of a nonnegative mpf value. The
    result is correctly rounded.
    """
    ...

def mpf_hypot(x, y, prec, rnd=...): # -> tuple[Literal[0], int | Any, Literal[-456], Literal[-2]] | tuple[Literal[0], Any, Any, Any] | tuple[Literal[0], int | Any, Literal[0], Literal[0]] | tuple[Any, Any, Any, Any] | tuple[Any, Any | Literal[1], Any, Any | Literal[1]] | tuple[Literal[1, 0], Any, Any, Any | int]:
    """Compute the Euclidean norm sqrt(x**2 + y**2) of two raw mpfs
    x and y."""
    ...

if BACKEND == 'sage':
    mpf_add = ...
    mpf_sub = ...
    mpf_mul = ...
    mpf_div = ...
    mpf_sqrt = ...
